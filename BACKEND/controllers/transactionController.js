const Transaction = require('../models/Transaction');
const Bill = require('../models/Bill');
const Purchase = require('../models/Purchase');
const Company = require('../models/Company');
const Worker = require('../models/Worker'); // Added Worker model
const { log } = require('../middleware/logger');
const mongoose = require('mongoose');
const ExcelJS = require('exceljs');
const PDFDocument = require('pdfkit');
const fs = require('fs');

// @desc    Create a new transaction
// @route   POST /api/transactions
// @access  Private/Admin
const   createTransaction = async (req, res) => {
  const {
    paymentDate,
    type, // 'IN' or 'OUT'
    companyId, // Optional
    workerId, // Optional: For salary payments
    category, // New field for transaction category
    relatedBillIds, // Array of Bill ObjectIds for 'IN' type
    relatedPurchaseIds, // Array of Purchase ObjectIds for 'OUT' type
    amount,
    paymentMethod,
    referenceNumber,
    description, // Can be auto-generated or manual
    notes,
  } = req.body;

  if (!paymentDate || !type || !amount || !paymentMethod || !description || !category) {
    return res.status(400).json({ message: 'Payment date, type, amount, payment method, description, and category are required.' });
  }
  if (parseFloat(amount) <= 0) {
    return res.status(400).json({ message: 'Transaction amount must be positive.' });
  }

  // const session = await mongoose.startSession(); // Removed for standalone MongoDB
  // session.startTransaction(); // Removed for standalone MongoDB

  try {
    let companyObjectId = null;
    if (companyId) {
        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ message: 'Associated company not found.' });
        }
        companyObjectId = company._id;
    }

    let workerObjectId = null;
    if (workerId) {
        const worker = await Worker.findById(workerId);
        if (!worker) {
            return res.status(404).json({ message: 'Associated worker not found.' });
        }
        workerObjectId = worker._id;
    }
    
    let autoGeneratedDescription = description;

    // Auto-generate description for salary
    if (category === 'Salary' && workerObjectId) {
        const worker = await Worker.findById(workerObjectId); // Fetch worker again to get name if not already available
        if (worker) {
            autoGeneratedDescription = `Salary paid to ${worker.name}`;
        } else {
            autoGeneratedDescription = `Salary paid to worker ID ${workerObjectId}`;
        }
    }


    // Step 1: Create and save the main transaction document
    const initialTransactionData = {
      paymentDate: new Date(paymentDate),
      type,
      company: companyObjectId,
      worker: workerObjectId,
      category,
      amount: parseFloat(amount),
      paymentMethod,
      referenceNumber,
      description: autoGeneratedDescription, // Use potentially auto-generated description
      notes,
      recordedBy: req.user._id,
      relatedBills: (relatedBillIds || []).map(id => ({ billId: id })),
      relatedPurchases: (relatedPurchaseIds || []).map(id => ({ purchaseId: id })),
    };

    const newTransaction = new Transaction(initialTransactionData);
    const savedTransaction = await newTransaction.save();

    // Re-assign autoGeneratedDescription for bill/purchase linking, as it might have been set for salary
    // If category is BillPayment or PurchasePayment, it will be overridden below.
    // Otherwise, the salary/misc description remains.
    if (category !== 'Salary') { // Reset if not salary, to be set by bill/purchase logic
        autoGeneratedDescription = savedTransaction.description;
    }
    let finalRelatedBills = [];
    let finalRelatedPurchases = [];

    // Step 2: Update related Bills
    if (type === 'IN' && relatedBillIds && relatedBillIds.length > 0) {
      let totalAmountAppliedToBills = 0;
      let billNumbersForDesc = [];

      for (const billId of relatedBillIds) {
        const bill = await Bill.findById(billId);
        if (!bill) {
          // This is a problem: transaction is saved, but a bill is not found.
          // For now, log and continue, but this indicates data inconsistency or bad input.
          log(`Error creating transaction ${savedTransaction._id}: Bill with ID ${billId} not found after transaction save.`, 'error');
          continue;
        }
        
        const remainingDue = bill.totalAmount - bill.totalPaidAmount;
        if (remainingDue > 0) {
            bill.paymentRecords.push({
                paymentDate: savedTransaction.paymentDate,
                amountPaid: remainingDue,
                transactionId: savedTransaction._id, // CRITICAL: Use the saved transaction's ID
                paymentMethod: savedTransaction.paymentMethod,
                referenceNumber: savedTransaction.referenceNumber,
                notes: `Payment part of transaction ${savedTransaction._id} for bill ${bill.billNumber}`
            });
            await bill.save();
            totalAmountAppliedToBills += remainingDue;
        }
        finalRelatedBills.push({ billId: bill._id, billNumber: bill.billNumber });
        billNumbersForDesc.push(bill.billNumber);
      }

      if (billNumbersForDesc.length > 0 && category === 'BillPayment') {
        autoGeneratedDescription = `Payment received for Bill(s): ${billNumbersForDesc.join(', ')}.`;
      }
      // Validate amount if it's specifically a bill payment
      if (category === 'BillPayment' && relatedBillIds.length > 0 && Math.abs(parseFloat(amount) - totalAmountAppliedToBills) > 0.01) {
          log(`Transaction ${savedTransaction._id} amount ${amount} does not match sum of bill dues ${totalAmountAppliedToBills} for IN transaction. Using provided amount.`, 'warn');
      }
    }
    // Step 2: Update related Purchases
    else if (type === 'OUT' && relatedPurchaseIds && relatedPurchaseIds.length > 0) {
      let totalAmountAppliedToPurchases = 0;
      let purchaseBillNumbersForDesc = [];

      for (const purchaseId of relatedPurchaseIds) {
        const purchase = await Purchase.findById(purchaseId);
        if (!purchase) {
          log(`Error creating transaction ${savedTransaction._id}: Purchase with ID ${purchaseId} not found after transaction save.`, 'error');
          continue;
        }
        
        const remainingDue = purchase.amount - purchase.totalPaidAmount;
        if(remainingDue > 0) {
            purchase.paymentRecords.push({
                paymentDate: savedTransaction.paymentDate,
                amountPaid: remainingDue,
                transactionId: savedTransaction._id, // CRITICAL: Use the saved transaction's ID
                paymentMethod: savedTransaction.paymentMethod,
                referenceNumber: savedTransaction.referenceNumber,
                notes: `Payment part of transaction ${savedTransaction._id} for purchase bill ${purchase.purchaseBillNumber}`
            });
            await purchase.save();
            totalAmountAppliedToPurchases += remainingDue;
        }
        finalRelatedPurchases.push({ purchaseId: purchase._id, purchaseBillNumber: purchase.purchaseBillNumber });
        purchaseBillNumbersForDesc.push(purchase.purchaseBillNumber);
      }
      if (purchaseBillNumbersForDesc.length > 0 && category === 'PurchasePayment') {
        autoGeneratedDescription = `Payment made for Purchase Bill(s): ${purchaseBillNumbersForDesc.join(', ')}.`;
      }
      // Validate amount if it's specifically a purchase payment
      if (category === 'PurchasePayment' && relatedPurchaseIds.length > 0 && Math.abs(parseFloat(amount) - totalAmountAppliedToPurchases) > 0.01) {
          log(`Transaction ${savedTransaction._id} amount ${amount} does not match sum of purchase dues ${totalAmountAppliedToPurchases} for OUT transaction. Using provided amount.`, 'warn');
      }
    }

    // Step 3: Update the transaction with the final description and related item details if changed
    let needsTransactionUpdate = false;
    // Update description only if it was auto-generated for bills/purchases and differs
    if ((category === 'BillPayment' || category === 'PurchasePayment') && savedTransaction.description !== autoGeneratedDescription) {
        savedTransaction.description = autoGeneratedDescription;
        needsTransactionUpdate = true;
    }

    if (type === 'IN' && category === 'BillPayment' && finalRelatedBills.length > 0) {
        savedTransaction.relatedBills = finalRelatedBills;
        needsTransactionUpdate = true;
    } else if (type === 'OUT' && category === 'PurchasePayment' && finalRelatedPurchases.length > 0) {
        savedTransaction.relatedPurchases = finalRelatedPurchases;
        needsTransactionUpdate = true;
    }
    // No need to update savedTransaction.worker as it's set initially

    let finalTransaction = savedTransaction;
    if (needsTransactionUpdate) {
        finalTransaction = await savedTransaction.save();
    }
    
    log(`Transaction ${finalTransaction.type} of amount ${finalTransaction.amount} created successfully by ${req.user.email}`, 'info');
    res.status(201).json(finalTransaction);

  } catch (error) {
    // await session.abortTransaction(); // Removed
    // session.endSession(); // Removed
    log(`Error creating transaction: ${error.message} - Stack: ${error.stack}`, 'error');
    if (error.name === 'ValidationError') {
      return res.status(400).json({ message: error.message });
    }
    res.status(500).json({ message: 'Server error while creating transaction.' });
  }
};


// @desc    Get all transactions (with optional filters)
// @route   GET /api/transactions
// @access  Private/Admin
const   getTransactions = async (req, res) => {
  const { companyId, workerId, category, type, paymentMethod, startDate, endDate, month, year } = req.query;
  const query = {};

  if (companyId) query.company = companyId;
  if (workerId) query.worker = workerId;
  if (category) query.category = category;
  if (type) query.type = type; // 'IN' or 'OUT'
  if (paymentMethod) query.paymentMethod = paymentMethod;

  if (month && year) {
    const firstDay = new Date(Date.UTC(year, parseInt(month) - 1, 1));
    const lastDay = new Date(Date.UTC(year, parseInt(month), 0, 23, 59, 59, 999));
    query.paymentDate = { $gte: firstDay, $lte: lastDay };
  } else if (startDate && endDate) {
    query.paymentDate = { $gte: new Date(startDate), $lte: new Date(new Date(endDate).setHours(23,59,59,999)) };
  } else if (startDate) {
    query.paymentDate = { $gte: new Date(startDate) };
  } else if (endDate) {
    query.paymentDate = { $lte: new Date(new Date(endDate).setHours(23,59,59,999)) };
  }

  try {
    const transactions = await Transaction.find(query)
      .populate('company', 'name')
      .populate('worker', 'name') // Populate worker name
      .populate('recordedBy', 'username email')
      .sort({ paymentDate: -1, createdAt: -1 });

    log(`Fetched transactions with query ${JSON.stringify(query)} by ${req.user.email}`, 'info');
    res.json(transactions);
  } catch (error) {
    log(`Error fetching transactions: ${error.message}`, 'error');
    res.status(500).json({ message: 'Server error while fetching transactions.' });
  }
};

// @desc    Get a single transaction by ID
// @route   GET /api/transactions/:id
// @access  Private/Admin
const   getTransactionById = async (req, res) => {
  try {
    const transaction = await Transaction.findById(req.params.id)
      .populate('company', 'name')
      .populate('worker', 'name') // Populate worker name
      .populate('recordedBy', 'username email')
      .populate('relatedBills.billId', 'billNumber totalAmount status')
      .populate('relatedPurchases.purchaseId', 'purchaseBillNumber amount paymentStatus');

    if (!transaction) {
      log(`Transaction not found with ID: ${req.params.id}`, 'warn');
      return res.status(404).json({ message: 'Transaction not found' });
    }
    log(`Fetched transaction by ID: ${transaction._id} by ${req.user.email}`, 'info');
    res.json(transaction);
  } catch (error) {
    log(`Error fetching transaction ID ${req.params.id}: ${error.message}`, 'error');
    res.status(500).json({ message: 'Server error while fetching transaction.' });
  }
};

// @desc    Update a transaction (Limited updates usually, e.g., notes, referenceNumber)
// @route   PUT /api/transactions/:id
// @access  Private/Admin
const   updateTransaction = async (req, res) => {
  // Updating financial details or linked bills/purchases of a transaction is complex
  // and can have cascading effects. Usually, it's better to reverse/adjust.
  // For this example, we'll allow updating non-critical fields like notes or reference.
  const { notes, referenceNumber, description, paymentDate, paymentMethod } = req.body;

  try {
    const transaction = await Transaction.findById(req.params.id);
    if (!transaction) {
      log(`Transaction update failed: Not found with ID: ${req.params.id}`, 'warn');
      return res.status(404).json({ message: 'Transaction not found' });
    }

    // Prevent updates to amount, type, or linked bills/purchases directly here
    // as it would require complex reconciliation.
    if (req.body.amount || req.body.type || req.body.relatedBillIds || req.body.relatedPurchaseIds || req.body.companyId) {
        log(`Transaction update attempt with restricted fields for ID: ${req.params.id}`, 'warn');
        return res.status(400).json({ message: 'Amount, type, company, or related bills/purchases cannot be directly updated. Please create a new adjusting transaction if needed.' });
    }

    if (notes !== undefined) transaction.notes = notes;
    if (referenceNumber !== undefined) transaction.referenceNumber = referenceNumber;
    if (description !== undefined) transaction.description = description;
    if (paymentDate !== undefined) transaction.paymentDate = new Date(paymentDate);
    if (paymentMethod !== undefined) transaction.paymentMethod = paymentMethod;


    const updatedTransaction = await transaction.save();
    log(`Transaction updated: ${updatedTransaction._id} by ${req.user.email}`, 'info');
    res.json(updatedTransaction);
  } catch (error) {
    log(`Error updating transaction ID ${req.params.id}: ${error.message}`, 'error');
    if (error.name === 'ValidationError') {
      return res.status(400).json({ message: error.message });
    }
    res.status(500).json({ message: 'Server error while updating transaction.' });
  }
};


// @desc    Delete a transaction (Potentially dangerous, may need to reverse linked actions)
// @route   DELETE /api/transactions/:id
// @access  Private/Admin
const   deleteTransaction = async (req, res) => {

  try {
    const transaction = await Transaction.findById(req.params.id); // Removed .session(session)
    if (!transaction) {

      log(`Transaction deletion failed: Not found with ID: ${req.params.id}`, 'warn');
      return res.status(404).json({ message: 'Transaction not found' });
    }

    // Reverse effects on Bills
    if (transaction.relatedBills && transaction.relatedBills.length > 0) {
      for (const relBill of transaction.relatedBills) {
        const bill = await Bill.findById(relBill.billId); 
        if (bill) {
          // Remove the specific payment record linked to this transaction
          bill.paymentRecords = bill.paymentRecords.filter(
            pr => pr.transactionId && pr.transactionId.toString() !== transaction._id.toString()
          );
          await bill.save(); // Removed { session }
        }
      }
    }

    // Reverse effects on Purchases
    if (transaction.relatedPurchases && transaction.relatedPurchases.length > 0) {
      for (const relPurchase of transaction.relatedPurchases) {
        const purchase = await Purchase.findById(relPurchase.purchaseId); // Removed .session(session)
        if (purchase) {
          purchase.paymentRecords = purchase.paymentRecords.filter(
            pr => pr.transactionId && pr.transactionId.toString() !== transaction._id.toString()
          );
          await purchase.save(); 
        }
      }
    }

    await transaction.deleteOne(); 


    log(`Transaction deleted: ${transaction._id} and linked payments reversed by ${req.user.email}`, 'info');
    res.json({ message: 'Transaction removed and linked payments updated.' });

  } catch (error) {
    log(`Error deleting transaction ID ${req.params.id}: ${error.message} - Stack: ${error.stack}`, 'error');
    res.status(500).json({ message: 'Server error while deleting transaction.' });
  }
};

// @desc    Get summary of transactions based on filters (totalIn, totalOut)
// @route   GET /api/transactions/summary
// @access  Private/Admin
const   getFilteredTransactionSummary = async (req, res) => {
  const { companyId, workerId, category, type, paymentMethod, startDate, endDate, month, year } = req.query;
  const query = {};

  if (companyId) query.company = new mongoose.Types.ObjectId(companyId);
  if (workerId) query.worker = new mongoose.Types.ObjectId(workerId);
  if (category) query.category = category;
  if (type) query.type = type;
  if (paymentMethod) query.paymentMethod = paymentMethod;

  if (month && year) {
    const firstDay = new Date(Date.UTC(year, parseInt(month) - 1, 1));
    const lastDay = new Date(Date.UTC(year, parseInt(month), 0, 23, 59, 59, 999));
    query.paymentDate = { $gte: firstDay, $lte: lastDay };
  } else if (startDate && endDate) {
    query.paymentDate = { $gte: new Date(startDate), $lte: new Date(new Date(endDate).setHours(23,59,59,999)) };
  } else if (startDate) {
    query.paymentDate = { $gte: new Date(startDate) };
  } else if (endDate) {
    query.paymentDate = { $lte: new Date(new Date(endDate).setHours(23,59,59,999)) };
  }

  try {
    const summary = await Transaction.aggregate([
      { $match: query },
      {
        $group: {
          _id: '$type', // Group by transaction type ('IN' or 'OUT')
          totalAmount: { $sum: '$amount' },
        },
      },
    ]);

    let filteredTotalIn = 0;
    let filteredTotalOut = 0;

    summary.forEach(item => {
      if (item._id === 'IN') {
        filteredTotalIn = item.totalAmount;
      } else if (item._id === 'OUT') {
        filteredTotalOut = item.totalAmount;
      }
    });
    
    log(`Fetched filtered transaction summary with query ${JSON.stringify(query)} by ${req.user.email}`, 'info');
    res.json({ filteredTotalIn, filteredTotalOut });

  } catch (error) {
    log(`Error fetching filtered transaction summary: ${error.message} - Stack: ${error.stack}`, 'error');
    res.status(500).json({ message: 'Server error while fetching filtered transaction summary.' });
  }
};

// @desc    Export transactions to Excel
// @route   GET /api/transactions/export/excel
// @access  Private/Admin
const exportTransactionsToExcel = async (req, res) => {
  try {
    // Reuse the same query logic from getTransactions
    const { companyId, workerId, category, type, paymentMethod, startDate, endDate, month, year } = req.query;
    const query = {};

    if (companyId) query.company = companyId;
    if (workerId) query.worker = workerId;
    if (category) query.category = category;
    if (type) query.type = type;
    if (paymentMethod) query.paymentMethod = paymentMethod;

    if (month && year) {
      const firstDay = new Date(Date.UTC(year, parseInt(month) - 1, 1));
      const lastDay = new Date(Date.UTC(year, parseInt(month), 0, 23, 59, 59, 999));
      query.paymentDate = { $gte: firstDay, $lte: lastDay };
    } else if (startDate && endDate) {
      query.paymentDate = { $gte: new Date(startDate), $lte: new Date(new Date(endDate).setHours(23,59,59,999)) };
    } else if (startDate) {
      query.paymentDate = { $gte: new Date(startDate) };
    } else if (endDate) {
      query.paymentDate = { $lte: new Date(new Date(endDate).setHours(23,59,59,999)) };
    }

    // Get transactions with necessary fields populated
    const transactions = await Transaction.find(query)
      .populate('company', 'name')
      .populate('worker', 'name')
      .populate('recordedBy', 'username')
      .sort({ paymentDate: -1, createdAt: -1 });

    // Create a new workbook
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Transactions');

    // Add headers
    worksheet.columns = [
      { header: 'ID', key: 'id', width: 10 },
      { header: 'Date', key: 'date', width: 15 },
      { header: 'Type', key: 'type', width: 10 },
      { header: 'Category', key: 'category', width: 20 },
      { header: 'Amount', key: 'amount', width: 15, style: { numFmt: '#,##0.00' } },
      { header: 'Company', key: 'company', width: 20 },
      { header: 'Worker', key: 'worker', width: 20 },
      { header: 'Payment Method', key: 'paymentMethod', width: 15 },
      { header: 'Reference', key: 'reference', width: 20 },
      { header: 'Description', key: 'description', width: 40 },
      { header: 'Recorded By', key: 'recordedBy', width: 20 },
      { header: 'Notes', key: 'notes', width: 40 }
    ];

    // Add data rows
    transactions.forEach(transaction => {
      worksheet.addRow({
        id: transaction._id,
        date: transaction.paymentDate.toISOString().split('T')[0],
        type: transaction.type,
        category: transaction.category,
        amount: transaction.amount,
        company: transaction.company?.name || 'N/A',
        worker: transaction.worker?.name || 'N/A',
        paymentMethod: transaction.paymentMethod,
        reference: transaction.referenceNumber || '',
        description: transaction.description,
        recordedBy: transaction.recordedBy?.username || 'System',
        notes: transaction.notes || ''
      });
    });

    // Style the header row
    worksheet.getRow(1).eachCell((cell) => {
      cell.font = { bold: true };
      cell.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFD3D3D3' }
      };
      cell.border = {
        top: { style: 'thin' },
        left: { style: 'thin' },
        bottom: { style: 'thin' },
        right: { style: 'thin' }
      };
    });

    // Set response headers
    res.setHeader(
      'Content-Type',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    );
    res.setHeader(
      'Content-Disposition',
      `attachment; filename=transactions_${new Date().toISOString().split('T')[0]}.xlsx`
    );

    // Write to response
    await workbook.xlsx.write(res);
    res.end();

    log(`Exported ${transactions.length} transactions to Excel by ${req.user.email}`, 'info');
  } catch (error) {
    log(`Error exporting transactions to Excel: ${error.message}`, 'error');
    res.status(500).json({ message: 'Server error while exporting transactions to Excel.' });
  }
};

// @desc    Export transactions to PDF
// @route   GET /api/transactions/export/pdf
// @access  Private/Admin
const exportTransactionsToPDF = async (req, res) => {
  try {
    // Get query parameters
    const { companyId, workerId, category, type, paymentMethod, startDate, endDate, month, year } = req.query;
    const query = {};

    if (companyId) query.company = companyId;
    if (workerId) query.worker = workerId;
    if (category) query.category = category;
    if (type) query.type = type;
    if (paymentMethod) query.paymentMethod = paymentMethod;

    if (month && year) {
      const firstDay = new Date(Date.UTC(year, parseInt(month) - 1, 1));
      const lastDay = new Date(Date.UTC(year, parseInt(month), 0, 23, 59, 59, 999));
      query.paymentDate = { $gte: firstDay, $lte: lastDay };
    } else if (startDate && endDate) {
      query.paymentDate = { $gte: new Date(startDate), $lte: new Date(new Date(endDate).setHours(23,59,59,999)) };
    } else if (startDate) {
      query.paymentDate = { $gte: new Date(startDate) };
    } else if (endDate) {
      query.paymentDate = { $lte: new Date(new Date(endDate).setHours(23,59,59,999)) };
    }

    // Get transactions with necessary fields populated
    const transactions = await Transaction.find(query)
      .populate('company', 'name')
      .populate('worker', 'name')
      .populate('recordedBy', 'username')
      .sort({ paymentDate: -1, createdAt: -1 });

    // Fetch company name for filter display
    let companyName = null;
    if (companyId) {
      const company = await Company.findById(companyId).select('name');
      companyName = company ? company.name : 'Unknown Company';
    }

    // Create a new PDF document
    const doc = new PDFDocument({ 
      margin: 40,
      size: 'A4',
      layout: 'portrait'
    });

    // Set response headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader(
      'Content-Disposition',
      `attachment; filename=transactions_${new Date().toISOString().split('T')[0]}.pdf`
    );

    // Pipe the PDF to the response
    doc.pipe(res);

    // Helper function to calculate text height
    const calculateTextHeight = (text, width, fontSize) => {
      if (!text) return fontSize;
      const words = text.split(' ');
      let line = '';
      let lines = 1;
      
      for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const testWidth = doc.font('Helvetica').fontSize(fontSize).widthOfString(testLine);
        if (testWidth > width && i > 0) {
          line = words[i] + ' ';
          lines++;
        } else {
          line = testLine;
        }
      }
      
      return lines * (fontSize + 2); // Add slight padding between lines
    };

    // Helper function to draw centered multi-line text
    const drawCenteredText = (text, x, y, width, height, fontSize = 8) => {
      if (!text) text = 'N/A';
      const lines = [];
      const words = text.split(' ');
      let line = '';
      
      for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const testWidth = doc.font('Helvetica').fontSize(fontSize).widthOfString(testLine);
        if (testWidth > width && i > 0) {
          lines.push(line.trim());
          line = words[i] + ' ';
        } else {
          line = testLine;
        }
      }
      lines.push(line.trim());

      // Calculate vertical center position
      const textHeight = lines.length * (fontSize + 2);
      const startY = y + (height - textHeight) / 2;
      
      // Draw each line centered
      lines.forEach((line, i) => {
        const lineWidth = doc.font('Helvetica').fontSize(fontSize).widthOfString(line);
        const lineX = x + (width - lineWidth) / 2;
        doc.text(line, lineX, startY + (i * (fontSize + 2)));
      });
    };

    // Helper function to draw table rows
    const drawTableRow = (y, columns, isHeader = false, rowHeight = 20) => {
      const colWidths = [80, 50, 70, 80, 140, 150]; // Increased Company/Worker column width
      const padding = 5;
      
      // Draw cell backgrounds for header
      if (isHeader) {
        doc
          .fillColor('#1155cc')
          .rect(40, y, 548, rowHeight)
          .fill();
      }

      // Draw cell borders
      doc.lineWidth(0.5).strokeColor('#cccccc');
      let xPos = 40;
      for (let i = 0; i < columns.length; i++) {
        doc
          .rect(xPos, y, colWidths[i], rowHeight)
          .stroke();
        xPos += colWidths[i];
      }

      // Draw text
      xPos = 40;
      doc.font(isHeader ? 'Helvetica-Bold' : 'Helvetica')
         .fontSize(8)
         .fillColor(isHeader ? '#ffffff' : '#000000');
      
      for (let i = 0; i < columns.length; i++) {
        const cellWidth = colWidths[i] - (padding * 2);
        const cellHeight = rowHeight - (padding * 2);
        
        drawCenteredText(
          columns[i],
          xPos + padding,
          y + padding,
          cellWidth,
          cellHeight
        );
        
        xPos += colWidths[i];
      }

      return y + rowHeight;
    };

    // Add header
    doc.font('Helvetica-Bold').fontSize(16)
       .fillColor('#1155cc')
       .text('TRANSACTIONS REPORT', { align: 'center' })
       .moveDown(0.5);
    
    doc.font('Helvetica').fontSize(10)
       .fillColor('#444444')
       .text(`Generated: ${new Date().toLocaleString('en-US', { month: 'long', day: 'numeric', year: 'numeric', hour: 'numeric', minute: 'numeric', timeZone: 'Asia/Kolkata', hour12: true })}`, { align: 'center' })
       .text(`User: ${req.user.email}`, { align: 'center' })
       .moveDown(1);

    // Add filters section
    doc.font('Helvetica-Bold').fontSize(12)
       .fillColor('#1155cc')
       .text('FILTERS APPLIED', { underline: true })
       .moveDown(0.5);
    
    let filterText = 'Showing all transactions';
    if (Object.keys(query).length > 0) {
      filterText = '';
      if (query.paymentDate) {
        if (month && year) {
          filterText += `• Period: ${new Intl.DateTimeFormat('en-US', { month: 'long' }).format(new Date(year, month-1))} ${year}\n`;
        } else {
          if (startDate) filterText += `• From: ${new Date(startDate).toLocaleDateString()}\n`;
          if (endDate) filterText += `• To: ${new Date(endDate).toLocaleDateString()}\n`;
        }
      }
      if (companyId) filterText += `• Company: ${companyName}\n`;
      if (workerId) filterText += `• Worker: ${workerId}\n`;
      if (category) filterText += `• Category: ${category}\n`;
      if (type) filterText += `• Type: ${type}\n`;
      if (paymentMethod) filterText += `• Payment Method: ${paymentMethod}\n`;
    }
    
    doc.font('Helvetica').fontSize(10)
       .fillColor('#000000')
       .text(filterText || 'No filters applied')
       .moveDown(1);

    // Add summary section
    const totalIn = transactions.filter(t => t.type === 'IN').reduce((sum, t) => sum + t.amount, 0);
    const totalOut = transactions.filter(t => t.type === 'OUT').reduce((sum, t) => sum + t.amount, 0);
    const netBalance = totalIn - totalOut;

    doc.font('Helvetica-Bold').fontSize(12)
       .fillColor('#1155cc')
       .text('SUMMARY', { underline: true })
       .moveDown(0.5)
       .font('Helvetica').fontSize(10)
       .text(`Total Income: $${totalIn.toFixed(2)}`, { indent: 20 })
       .text(`Total Expenses: $${totalOut.toFixed(2)}`, { indent: 20 })
       .text(`Net Balance: $${netBalance.toFixed(2)}`, { indent: 20 })
       .moveDown(1.5);

    // Add transactions table header
    let yPos = drawTableRow(doc.y, [
      'Date',
      'Type',
      'Amount',
      'Method',
      'Description',
      'Company'
    ], true);

    // Add transactions rows
    transactions.forEach((transaction, index) => {
      // Calculate required row height based on content
      const companyWorker = transaction.company?.name || transaction.worker?.name || 'N/A';
      const descHeight = calculateTextHeight(transaction.description, 130, 8);
      const companyHeight = calculateTextHeight(companyWorker, 140, 8);
      const rowHeight = Math.max(24, descHeight + 10, companyHeight + 10);

      // Check if we need a new page
      if (yPos + rowHeight > doc.page.height - 50) {
        doc.addPage();
        yPos = 40; // Reset Y position for new page
        yPos = drawTableRow(yPos, [
          'Date',
          'Type',
          'Amount',
          'Method',
          'Description',
          'Company'
        ], true, rowHeight);
      }

      // Alternate row colors
      if (index % 2 === 0) {
        doc.fillColor('#f5f5f5')
           .rect(40, yPos, 548, rowHeight)
           .fill();
      }

      // Format date
      const formattedDate = transaction.paymentDate.toISOString().split('T')[0];
      
      // Format amount
      const formattedAmount = `$${transaction.amount.toFixed(2)}`;

      yPos = drawTableRow(yPos, [
        formattedDate,
        transaction.type,
        formattedAmount,
        transaction.paymentMethod,
        transaction.description,
        companyWorker
      ], false, rowHeight);
    });

    // Finalize the PDF
    doc.end();

    log(`Exported ${transactions.length} transactions to PDF by ${req.user.email}`, 'info');
  } catch (error) {
    log(`Error exporting transactions to PDF: ${error.message}`, 'error');
    if (!res.headersSent) {
      res.status(500).json({ message: 'Server error while exporting transactions to PDF.' });
    }
  }
};

module.exports = {
  createTransaction,
  getTransactions,
  getTransactionById,
  updateTransaction,
  deleteTransaction,
  getFilteredTransactionSummary,
  exportTransactionsToExcel,
  exportTransactionsToPDF
};